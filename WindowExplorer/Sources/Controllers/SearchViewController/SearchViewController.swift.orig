//  Copyright Â© 2018 JABT. All rights reserved.

import Cocoa
import PromiseKit
import CoreLocation


protocol SearchItemDisplayable {
    var title: String { get }
}


class SearchViewController: BaseViewController, NSCollectionViewDataSource, NSCollectionViewDelegateFlowLayout {
    static let storyboard = NSStoryboard.Name(rawValue: "Search")

    @IBOutlet weak var primaryCollectionView: NSCollectionView!
    @IBOutlet weak var secondaryCollectionView: NSCollectionView!
    @IBOutlet weak var tertiaryCollectionView: NSCollectionView!
    @IBOutlet weak var secondaryTextField: NSTextField!
    @IBOutlet weak var tertiaryTextField: NSTextField!
    @IBOutlet weak var collapseButtonArea: NSView!
    
    private var selectedType: RecordType?
    private var selectedIndexForView = [NSCollectionView: IndexPath]()

    private lazy var titleViews: [NSTextField] = [titleLabel, secondaryTextField, tertiaryTextField]
    private lazy var collectionViews: [NSCollectionView] = [primaryCollectionView, secondaryCollectionView, tertiaryCollectionView]
    private lazy var focusedCollectionView: NSCollectionView = primaryCollectionView
    private lazy var searchItemsForView: [NSCollectionView: [SearchItemDisplayable]] = [
        primaryCollectionView: RecordType.allValues,
        secondaryCollectionView: [],
        tertiaryCollectionView: []
    ]

    private lazy var convertDict = [String: [School]]()
    var count: Int = 0
    var count1 = 0
    var successCount = 0
    var index = 0

    private var geoCodeTimer: Timer?

    private var schoolsArray: [School] = []


    private struct Constants {
        static let animationDuration = 0.5
        static let searchItemHeight: CGFloat = 70
    }


    // MARK: Life-Cycle

    override func viewDidLoad() {
        super.viewDidLoad()
        titleLabel.attributedStringValue = NSAttributedString(string: titleLabel.stringValue, attributes: style.windowTitleAttributes)

        setupGestures()
        resetCloseWindowTimer()
        animateViewIn()


        associateProvincesToSchools()
    }


    // MARK: Setup

    private func setupGestures() {
        collectionViews.forEach { collectionView in
            let collectionViewPan = PanGestureRecognizer()
            gestureManager.add(collectionViewPan, to: collectionView)
            collectionViewPan.gestureUpdated = handleCollectionViewPan(_:)

            let collectionViewTap = TapGestureRecognizer(withDelay: true)
            gestureManager.add(collectionViewTap, to: collectionView)
            collectionViewTap.gestureUpdated = handleCollectionViewTap(_:)
        }

        let collapseButtonTap = TapGestureRecognizer()
        gestureManager.add(collapseButtonTap, to: collapseButtonArea)
        collapseButtonTap.gestureUpdated = handleCollapseButtonTap(_:)
    }


    // MARK: GestureHandling

    private func handleCollectionViewPan(_ gesture: GestureRecognizer) {
        guard let pan = gesture as? PanGestureRecognizer, let collectionView = gestureManager.view(for: pan) as? NSCollectionView else {
            return
        }

        switch pan.state {
        case .recognized, .momentum:
            var rect = collectionView.visibleRect
            rect.origin.y += pan.delta.dy
            collectionView.scrollToVisible(rect)
        default:
            return
        }
    }

    private func handleCollectionViewTap(_ gesture: GestureRecognizer) {
        guard let tap = gesture as? TapGestureRecognizer,
            let collectionView = gestureManager.view(for: tap) as? NSCollectionView,
            let location = tap.position,
            let indexPath = collectionView.indexPathForItem(at: location + collectionView.visibleRect.origin),
            let searchItem = collectionView.item(at: indexPath) as? SearchItemView,
            tap.state == .ended else {
            return
        }

        unselectItem(for: collectionView)
        selectedIndexForView[collectionView] = indexPath
        searchItem.set(highlighted: true)
        toggle(to: collectionView) { [weak self] in
            self?.select(searchItem, in: collectionView)
        }
    }

    private func handleCollapseButtonTap(_ gesture: GestureRecognizer) {
        guard let tap = gesture as? TapGestureRecognizer, tap.state == .ended else {
            return
        }

        if let index = collectionViews.index(of: focusedCollectionView), let previous = collectionViews.at(index: index - 1) {
            toggle(to: previous)
        }
    }


    // MARK: NSCollectionViewDelegate & NSCollectionViewDataSource

    func collectionView(_ collectionView: NSCollectionView, numberOfItemsInSection section: Int) -> Int {
        guard let searchItems = searchItemsForView[collectionView] else {
            return 0
        }

        return searchItems.count
    }

    func collectionView(_ collectionView: NSCollectionView, itemForRepresentedObjectAt indexPath: IndexPath) -> NSCollectionViewItem {
        guard let searchItemView = collectionView.makeItem(withIdentifier: SearchItemView.identifier, for: indexPath) as? SearchItemView, let searchItems = searchItemsForView[collectionView] else {
            return NSCollectionViewItem()
        }

        // Check if index path is selected
        if let selectedIndex = selectedIndexForView[collectionView] {
            searchItemView.set(highlighted: selectedIndex == indexPath)
        }

        searchItemView.type = selectedType
        searchItemView.item = searchItems.at(index: indexPath.item)
        return searchItemView
    }

    func collectionView(_ collectionView: NSCollectionView, layout collectionViewLayout: NSCollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> NSSize {
        return CGSize(width: collectionView.frame.size.width, height: Constants.searchItemHeight)
    }


    // MARK: Overrides

    override func animateViewIn() {
        primaryCollectionView.alphaValue = 0
        windowDragArea.alphaValue = 0
        secondaryCollectionView.alphaValue = 0
        tertiaryCollectionView.alphaValue = 0
        secondaryTextField.alphaValue = 0
        tertiaryTextField.alphaValue = 0
        collapseButtonArea.alphaValue = 0
        NSAnimationContext.runAnimationGroup({ _ in
            NSAnimationContext.current.duration = Constants.animationDuration
            primaryCollectionView.animator().alphaValue = 1
            windowDragArea.animator().alphaValue = 1
        })
    }

    override func animateViewOut() {
        NSAnimationContext.runAnimationGroup({ _ in
            NSAnimationContext.current.duration = Constants.animationDuration
            view.animator().alphaValue = 0
        }, completionHandler: { [weak self] in
            if let strongSelf = self {
                WindowManager.instance.closeWindow(for: strongSelf)
            }
        })
    }


    // MARK: Helpers

    private func select(_ view: SearchItemView, in collectionView: NSCollectionView) {
        guard let indexPath = selectedIndexForView[collectionView], view == collectionView.item(at: indexPath) else {
            return
        }
        
        switch collectionView {
        case primaryCollectionView:
            if let recordType = view.item as? RecordType {
                selectedType = recordType
                searchItemsForView[secondaryCollectionView] = searchItems(for: recordType)
                secondaryTextField.attributedStringValue = title(for: recordType)
                secondaryCollectionView.reloadData()
                secondaryCollectionView.scroll(.zero)
                toggle(to: secondaryCollectionView)
            }
        case secondaryCollectionView:
            if let selectedType = selectedType, let group = view.item as? LetterGroup {
                view.set(loading: true)
                RecordFactory.records(for: selectedType, in: group) { [weak self] records in
                    view.set(loading: false)
                    if let records = records {
                        self?.load(records, of: selectedType)
                    }
                }
            }
        case tertiaryCollectionView:
            if let record = view.item as? RecordDisplayable {
                display(record)
            }
        default:
            break
        }
    }

    private func toggle(to view: NSCollectionView, completion: (() -> Void)? = nil) {
        guard let window = view.window, let index = collectionViews.index(of: view) else {
            return
        }

        // Unselect nested search items
        collectionViews.enumerated().forEach { indexOfView, collectionView in
            if indexOfView > index {
                unselectItem(for: collectionView)
            }
        }

        NSAnimationContext.runAnimationGroup({ _ in
            NSAnimationContext.current.duration = Constants.animationDuration
            for indexOfView in 0 ..< collectionViews.count {
                collectionViews.at(index: indexOfView)?.animator().alphaValue = indexOfView <= index ? 1 : 0
                titleViews.at(index: indexOfView)?.animator().alphaValue = indexOfView <= index ? 1 : 0
            }
            collapseButtonArea.animator().alphaValue = index.isZero ? 0 : 1
        }, completionHandler: completion)

        var frame = window.frame
        frame.size.width = style.searchWindowSize.width * CGFloat(index + 1)
        window.setFrame(frame, display: true, animate: true)
        focusedCollectionView = view
    }

    /// Returns a collection of search items used as the second level of a search query
    private func searchItems(for type: RecordType) -> [SearchItemDisplayable] {
        switch type {
        case .event, .artifact, .organization, .theme:
            return LetterGroup.allValues
        case .school:
            return Province.allValues
        }
    }

    /// Returns the attributed string to present as a tile in the window drag area
    private func title(for type: RecordType) -> NSAttributedString {
        switch type {
        case .event, .artifact, .organization, .theme:
            return NSAttributedString(string: "Range", attributes: style.windowTitleAttributes)
        case .school:
            return NSAttributedString(string: "Province", attributes: style.windowTitleAttributes)
        }
    }

    /// Loads records into and toggles the tertiary collection view
    private func load(_ records: [RecordDisplayable], of type: RecordType) {
        searchItemsForView[tertiaryCollectionView] = records
        tertiaryCollectionView.reloadData()
        tertiaryCollectionView.scroll(.zero)
        tertiaryTextField.attributedStringValue = NSAttributedString(string: type.title, attributes: style.windowTitleAttributes)
        toggle(to: tertiaryCollectionView)
    }

    private func display(_ record: RecordDisplayable) {
        guard let window = view.window else {
            return
        }

        let location = CGPoint(x: window.frame.maxX + style.windowMargins, y: window.frame.minY)
        RecordFactory.record(for: record.type, id: record.id) { record in
            if let record = record {
                WindowManager.instance.display(.record(record), at: location)
            }
<<<<<<< HEAD
=======
        }
    }

}



private extension SearchViewController {
    class SchoolFactory {

        static func getAllSchools(then completionHandler: @escaping ([School]?) -> Void) {
            firstly {
                try CachingNetwork.getSchools()
            }.then { schools in
                completionHandler(schools)
            }.catch { error in
                print(error.localizedDescription)
                completionHandler(nil)
            }
        }
    }
}

private extension SearchViewController {
    typealias SuccessHandler = ([String: [School]]) -> ()
    typealias FailureHandler = () -> ()

    func associateProvincesToSchools() {
        SchoolFactory.getAllSchools { [weak self] (schools) in
            guard let strongSelf = self else {
                return
            }

            guard let schools = schools else {
                return
            }
            let schoolsWithLatLong = strongSelf.filter(schools)

            strongSelf.geoCode(schoolsWithLatLong, then: { (provinceKeySchoolDict) in
                // initialize and store property in the global singleton instance
            })
        }
    }

    func filter(_ schools: [School]) -> [School] {
        return schools.filter {
            $0.coordinate != nil
        }
    }

    func geoCode(_ schools: [School], with results: [String: [School]] = [:], then completionHandler: @escaping SuccessHandler) {
        guard let school = schools.first,
            let latitude = school.coordinate?.latitude,
            let longitude = school.coordinate?.longitude else {
            completionHandler(results)
            return
        }

        let location = CLLocation(latitude: latitude, longitude: longitude)
        let geocoder = CLGeocoder()

        geocoder.reverseGeocodeLocation(location) { (placemarks, error) in
            var updatedResults = results

            if let error = error {
                print(error.localizedDescription)
                self.geoCodeTimer?.invalidate()
                self.geoCodeTimer = Timer.scheduledTimer(withTimeInterval: 5, repeats: false, block: { [weak self] (timer) in
                    guard let strongSelf = self else {
                        return
                    }

                    strongSelf.geoCode(schools, with: updatedResults, then: completionHandler)
                })

            } else if let placemark = placemarks?.first, let province = placemark.administrativeArea {
                if let _  = updatedResults[province] {
                    updatedResults[province]?.append(school)
                } else {
                    updatedResults[province] = [school]
                }
            }

            let remainingSchools = Array(schools[1..<schools.count])

            self.geoCode(remainingSchools, with: updatedResults, then: completionHandler)

        }
    }





    func getAllSchools() {
        firstly {
            try CachingNetwork.getSchools()
            }.then { [weak self] schools in

                self?.schoolsArray = schools

            }.then { [weak self] schools in
                self?.mapSchool()

            }.catch { (error) in
                print(error)
        }
    }

    @objc
    func mapSchool() {

        guard index < schoolsArray.count else {
            return
        }
        print("Index: \(index)")

        let school = schoolsArray[index]

        mapOneSchoolToCLPlacemark(school: school, success: { (province) in
//            if let _ = self?.convertDict[province] {
//                self?.convertDict[province]?.append(school)
//            } else {
//                self?.convertDict[province] = [school]
//            }
//            self?.index = (self?.index)! + 1
//            self?.mapSchool()

        }, failure: {
            Timer.scheduledTimer(timeInterval: 5, target: self, selector: #selector(self.mapSchool), userInfo: nil, repeats: false)
//            self.mapSchool()
        })
    }

    func mapOneSchoolToCLPlacemark(school: School, success successHandler: @escaping SuccessHandler, failure failureHandler: @escaping FailureHandler) {
        let geocoder = CLGeocoder()

        if let latitude = school.coordinate?.latitude, let longitude = school.coordinate?.longitude {
            let location = CLLocation(latitude: latitude, longitude: longitude)

            geocoder.reverseGeocodeLocation(location) { (placemarks, error) in

                if error != nil {
//                    print(error?.localizedDescription)
                    self.count1 = self.count1 + 1
                    print("Failure Error: \(self.count1)")
                    failureHandler()
                } else if let placemark = placemarks?[0], let _ = placemark.administrativeArea {
                    self.successCount = self.successCount + 1
                    print("Success: \(self.successCount)")
//                    successHandler(area)
                }
            }
>>>>>>> added GeocodeHelper singleton class

        } else {
            count = count + 1
            print("Failure LatLong: \(count)")
            failureHandler()
        }
    }

    // Removes all state from the currently selected view of the given collectionview
    private func unselectItem(for collectionView: NSCollectionView) {
        guard let indexPath = selectedIndexForView[collectionView] else {
            return
        }

        selectedIndexForView.removeValue(forKey: collectionView)
        if let view = collectionView.item(at: indexPath) as? SearchItemView {
            view.set(highlighted: false)
            view.set(loading: false)
        }
    }
}
